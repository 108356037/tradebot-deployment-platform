// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UploadClient is the client API for Upload service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UploadClient interface {
	UploadFile(ctx context.Context, opts ...grpc.CallOption) (Upload_UploadFileClient, error)
}

type uploadClient struct {
	cc grpc.ClientConnInterface
}

func NewUploadClient(cc grpc.ClientConnInterface) UploadClient {
	return &uploadClient{cc}
}

func (c *uploadClient) UploadFile(ctx context.Context, opts ...grpc.CallOption) (Upload_UploadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &Upload_ServiceDesc.Streams[0], "/Upload/UploadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &uploadUploadFileClient{stream}
	return x, nil
}

type Upload_UploadFileClient interface {
	Send(*UploadReq) error
	CloseAndRecv() (*UploadRes, error)
	grpc.ClientStream
}

type uploadUploadFileClient struct {
	grpc.ClientStream
}

func (x *uploadUploadFileClient) Send(m *UploadReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *uploadUploadFileClient) CloseAndRecv() (*UploadRes, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// UploadServer is the server API for Upload service.
// All implementations must embed UnimplementedUploadServer
// for forward compatibility
type UploadServer interface {
	UploadFile(Upload_UploadFileServer) error
	mustEmbedUnimplementedUploadServer()
}

// UnimplementedUploadServer must be embedded to have forward compatible implementations.
type UnimplementedUploadServer struct {
}

func (UnimplementedUploadServer) UploadFile(Upload_UploadFileServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadFile not implemented")
}
func (UnimplementedUploadServer) mustEmbedUnimplementedUploadServer() {}

// UnsafeUploadServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UploadServer will
// result in compilation errors.
type UnsafeUploadServer interface {
	mustEmbedUnimplementedUploadServer()
}

func RegisterUploadServer(s grpc.ServiceRegistrar, srv UploadServer) {
	s.RegisterService(&Upload_ServiceDesc, srv)
}

func _Upload_UploadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UploadServer).UploadFile(&uploadUploadFileServer{stream})
}

type Upload_UploadFileServer interface {
	SendAndClose(*UploadRes) error
	Recv() (*UploadReq, error)
	grpc.ServerStream
}

type uploadUploadFileServer struct {
	grpc.ServerStream
}

func (x *uploadUploadFileServer) SendAndClose(m *UploadRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *uploadUploadFileServer) Recv() (*UploadReq, error) {
	m := new(UploadReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Upload_ServiceDesc is the grpc.ServiceDesc for Upload service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Upload_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Upload",
	HandlerType: (*UploadServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadFile",
			Handler:       _Upload_UploadFile_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "proto/service.proto",
}

// BuildClient is the client API for Build service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BuildClient interface {
	BuildFunc(ctx context.Context, in *BuildReq, opts ...grpc.CallOption) (*BuildRes, error)
}

type buildClient struct {
	cc grpc.ClientConnInterface
}

func NewBuildClient(cc grpc.ClientConnInterface) BuildClient {
	return &buildClient{cc}
}

func (c *buildClient) BuildFunc(ctx context.Context, in *BuildReq, opts ...grpc.CallOption) (*BuildRes, error) {
	out := new(BuildRes)
	err := c.cc.Invoke(ctx, "/Build/BuildFunc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BuildServer is the server API for Build service.
// All implementations must embed UnimplementedBuildServer
// for forward compatibility
type BuildServer interface {
	BuildFunc(context.Context, *BuildReq) (*BuildRes, error)
	mustEmbedUnimplementedBuildServer()
}

// UnimplementedBuildServer must be embedded to have forward compatible implementations.
type UnimplementedBuildServer struct {
}

func (UnimplementedBuildServer) BuildFunc(context.Context, *BuildReq) (*BuildRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildFunc not implemented")
}
func (UnimplementedBuildServer) mustEmbedUnimplementedBuildServer() {}

// UnsafeBuildServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BuildServer will
// result in compilation errors.
type UnsafeBuildServer interface {
	mustEmbedUnimplementedBuildServer()
}

func RegisterBuildServer(s grpc.ServiceRegistrar, srv BuildServer) {
	s.RegisterService(&Build_ServiceDesc, srv)
}

func _Build_BuildFunc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildServer).BuildFunc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Build/BuildFunc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildServer).BuildFunc(ctx, req.(*BuildReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Build_ServiceDesc is the grpc.ServiceDesc for Build service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Build_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Build",
	HandlerType: (*BuildServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BuildFunc",
			Handler:    _Build_BuildFunc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/service.proto",
}

// PushClient is the client API for Push service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PushClient interface {
	PushFunc(ctx context.Context, in *PushReq, opts ...grpc.CallOption) (*PushRes, error)
}

type pushClient struct {
	cc grpc.ClientConnInterface
}

func NewPushClient(cc grpc.ClientConnInterface) PushClient {
	return &pushClient{cc}
}

func (c *pushClient) PushFunc(ctx context.Context, in *PushReq, opts ...grpc.CallOption) (*PushRes, error) {
	out := new(PushRes)
	err := c.cc.Invoke(ctx, "/Push/PushFunc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PushServer is the server API for Push service.
// All implementations must embed UnimplementedPushServer
// for forward compatibility
type PushServer interface {
	PushFunc(context.Context, *PushReq) (*PushRes, error)
	mustEmbedUnimplementedPushServer()
}

// UnimplementedPushServer must be embedded to have forward compatible implementations.
type UnimplementedPushServer struct {
}

func (UnimplementedPushServer) PushFunc(context.Context, *PushReq) (*PushRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushFunc not implemented")
}
func (UnimplementedPushServer) mustEmbedUnimplementedPushServer() {}

// UnsafePushServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PushServer will
// result in compilation errors.
type UnsafePushServer interface {
	mustEmbedUnimplementedPushServer()
}

func RegisterPushServer(s grpc.ServiceRegistrar, srv PushServer) {
	s.RegisterService(&Push_ServiceDesc, srv)
}

func _Push_PushFunc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushServer).PushFunc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Push/PushFunc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushServer).PushFunc(ctx, req.(*PushReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Push_ServiceDesc is the grpc.ServiceDesc for Push service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Push_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Push",
	HandlerType: (*PushServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushFunc",
			Handler:    _Push_PushFunc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/service.proto",
}

// DeployClient is the client API for Deploy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeployClient interface {
	DeployFunc(ctx context.Context, in *DeployReq, opts ...grpc.CallOption) (*DeployRes, error)
}

type deployClient struct {
	cc grpc.ClientConnInterface
}

func NewDeployClient(cc grpc.ClientConnInterface) DeployClient {
	return &deployClient{cc}
}

func (c *deployClient) DeployFunc(ctx context.Context, in *DeployReq, opts ...grpc.CallOption) (*DeployRes, error) {
	out := new(DeployRes)
	err := c.cc.Invoke(ctx, "/Deploy/DeployFunc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeployServer is the server API for Deploy service.
// All implementations must embed UnimplementedDeployServer
// for forward compatibility
type DeployServer interface {
	DeployFunc(context.Context, *DeployReq) (*DeployRes, error)
	mustEmbedUnimplementedDeployServer()
}

// UnimplementedDeployServer must be embedded to have forward compatible implementations.
type UnimplementedDeployServer struct {
}

func (UnimplementedDeployServer) DeployFunc(context.Context, *DeployReq) (*DeployRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeployFunc not implemented")
}
func (UnimplementedDeployServer) mustEmbedUnimplementedDeployServer() {}

// UnsafeDeployServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeployServer will
// result in compilation errors.
type UnsafeDeployServer interface {
	mustEmbedUnimplementedDeployServer()
}

func RegisterDeployServer(s grpc.ServiceRegistrar, srv DeployServer) {
	s.RegisterService(&Deploy_ServiceDesc, srv)
}

func _Deploy_DeployFunc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployServer).DeployFunc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Deploy/DeployFunc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployServer).DeployFunc(ctx, req.(*DeployReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Deploy_ServiceDesc is the grpc.ServiceDesc for Deploy service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Deploy_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Deploy",
	HandlerType: (*DeployServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeployFunc",
			Handler:    _Deploy_DeployFunc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/service.proto",
}

// RemoveClient is the client API for Remove service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RemoveClient interface {
	RemoveFunc(ctx context.Context, in *RemoveReq, opts ...grpc.CallOption) (*RemoveRes, error)
}

type removeClient struct {
	cc grpc.ClientConnInterface
}

func NewRemoveClient(cc grpc.ClientConnInterface) RemoveClient {
	return &removeClient{cc}
}

func (c *removeClient) RemoveFunc(ctx context.Context, in *RemoveReq, opts ...grpc.CallOption) (*RemoveRes, error) {
	out := new(RemoveRes)
	err := c.cc.Invoke(ctx, "/Remove/RemoveFunc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RemoveServer is the server API for Remove service.
// All implementations must embed UnimplementedRemoveServer
// for forward compatibility
type RemoveServer interface {
	RemoveFunc(context.Context, *RemoveReq) (*RemoveRes, error)
	mustEmbedUnimplementedRemoveServer()
}

// UnimplementedRemoveServer must be embedded to have forward compatible implementations.
type UnimplementedRemoveServer struct {
}

func (UnimplementedRemoveServer) RemoveFunc(context.Context, *RemoveReq) (*RemoveRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFunc not implemented")
}
func (UnimplementedRemoveServer) mustEmbedUnimplementedRemoveServer() {}

// UnsafeRemoveServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RemoveServer will
// result in compilation errors.
type UnsafeRemoveServer interface {
	mustEmbedUnimplementedRemoveServer()
}

func RegisterRemoveServer(s grpc.ServiceRegistrar, srv RemoveServer) {
	s.RegisterService(&Remove_ServiceDesc, srv)
}

func _Remove_RemoveFunc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoveServer).RemoveFunc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Remove/RemoveFunc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoveServer).RemoveFunc(ctx, req.(*RemoveReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Remove_ServiceDesc is the grpc.ServiceDesc for Remove service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Remove_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Remove",
	HandlerType: (*RemoveServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RemoveFunc",
			Handler:    _Remove_RemoveFunc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/service.proto",
}

// ScheduleClient is the client API for Schedule service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ScheduleClient interface {
	ScheduleFunc(ctx context.Context, in *ScheduleReq, opts ...grpc.CallOption) (*ScheduleRes, error)
}

type scheduleClient struct {
	cc grpc.ClientConnInterface
}

func NewScheduleClient(cc grpc.ClientConnInterface) ScheduleClient {
	return &scheduleClient{cc}
}

func (c *scheduleClient) ScheduleFunc(ctx context.Context, in *ScheduleReq, opts ...grpc.CallOption) (*ScheduleRes, error) {
	out := new(ScheduleRes)
	err := c.cc.Invoke(ctx, "/Schedule/ScheduleFunc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ScheduleServer is the server API for Schedule service.
// All implementations must embed UnimplementedScheduleServer
// for forward compatibility
type ScheduleServer interface {
	ScheduleFunc(context.Context, *ScheduleReq) (*ScheduleRes, error)
	mustEmbedUnimplementedScheduleServer()
}

// UnimplementedScheduleServer must be embedded to have forward compatible implementations.
type UnimplementedScheduleServer struct {
}

func (UnimplementedScheduleServer) ScheduleFunc(context.Context, *ScheduleReq) (*ScheduleRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScheduleFunc not implemented")
}
func (UnimplementedScheduleServer) mustEmbedUnimplementedScheduleServer() {}

// UnsafeScheduleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ScheduleServer will
// result in compilation errors.
type UnsafeScheduleServer interface {
	mustEmbedUnimplementedScheduleServer()
}

func RegisterScheduleServer(s grpc.ServiceRegistrar, srv ScheduleServer) {
	s.RegisterService(&Schedule_ServiceDesc, srv)
}

func _Schedule_ScheduleFunc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).ScheduleFunc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Schedule/ScheduleFunc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).ScheduleFunc(ctx, req.(*ScheduleReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Schedule_ServiceDesc is the grpc.ServiceDesc for Schedule service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Schedule_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Schedule",
	HandlerType: (*ScheduleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ScheduleFunc",
			Handler:    _Schedule_ScheduleFunc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/service.proto",
}

// AsyncInvokeClient is the client API for AsyncInvoke service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AsyncInvokeClient interface {
	AsyncInvokeFunc(ctx context.Context, in *AsyncInvokeReq, opts ...grpc.CallOption) (*AsyncInvokeRes, error)
}

type asyncInvokeClient struct {
	cc grpc.ClientConnInterface
}

func NewAsyncInvokeClient(cc grpc.ClientConnInterface) AsyncInvokeClient {
	return &asyncInvokeClient{cc}
}

func (c *asyncInvokeClient) AsyncInvokeFunc(ctx context.Context, in *AsyncInvokeReq, opts ...grpc.CallOption) (*AsyncInvokeRes, error) {
	out := new(AsyncInvokeRes)
	err := c.cc.Invoke(ctx, "/AsyncInvoke/AsyncInvokeFunc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AsyncInvokeServer is the server API for AsyncInvoke service.
// All implementations must embed UnimplementedAsyncInvokeServer
// for forward compatibility
type AsyncInvokeServer interface {
	AsyncInvokeFunc(context.Context, *AsyncInvokeReq) (*AsyncInvokeRes, error)
	mustEmbedUnimplementedAsyncInvokeServer()
}

// UnimplementedAsyncInvokeServer must be embedded to have forward compatible implementations.
type UnimplementedAsyncInvokeServer struct {
}

func (UnimplementedAsyncInvokeServer) AsyncInvokeFunc(context.Context, *AsyncInvokeReq) (*AsyncInvokeRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AsyncInvokeFunc not implemented")
}
func (UnimplementedAsyncInvokeServer) mustEmbedUnimplementedAsyncInvokeServer() {}

// UnsafeAsyncInvokeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AsyncInvokeServer will
// result in compilation errors.
type UnsafeAsyncInvokeServer interface {
	mustEmbedUnimplementedAsyncInvokeServer()
}

func RegisterAsyncInvokeServer(s grpc.ServiceRegistrar, srv AsyncInvokeServer) {
	s.RegisterService(&AsyncInvoke_ServiceDesc, srv)
}

func _AsyncInvoke_AsyncInvokeFunc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AsyncInvokeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsyncInvokeServer).AsyncInvokeFunc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AsyncInvoke/AsyncInvokeFunc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsyncInvokeServer).AsyncInvokeFunc(ctx, req.(*AsyncInvokeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// AsyncInvoke_ServiceDesc is the grpc.ServiceDesc for AsyncInvoke service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AsyncInvoke_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "AsyncInvoke",
	HandlerType: (*AsyncInvokeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AsyncInvokeFunc",
			Handler:    _AsyncInvoke_AsyncInvokeFunc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/service.proto",
}

// DeployBotClient is the client API for DeployBot service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeployBotClient interface {
	DeployBotFunc(ctx context.Context, in *DeployBotReq, opts ...grpc.CallOption) (*DeployBotRes, error)
}

type deployBotClient struct {
	cc grpc.ClientConnInterface
}

func NewDeployBotClient(cc grpc.ClientConnInterface) DeployBotClient {
	return &deployBotClient{cc}
}

func (c *deployBotClient) DeployBotFunc(ctx context.Context, in *DeployBotReq, opts ...grpc.CallOption) (*DeployBotRes, error) {
	out := new(DeployBotRes)
	err := c.cc.Invoke(ctx, "/DeployBot/DeployBotFunc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeployBotServer is the server API for DeployBot service.
// All implementations must embed UnimplementedDeployBotServer
// for forward compatibility
type DeployBotServer interface {
	DeployBotFunc(context.Context, *DeployBotReq) (*DeployBotRes, error)
	mustEmbedUnimplementedDeployBotServer()
}

// UnimplementedDeployBotServer must be embedded to have forward compatible implementations.
type UnimplementedDeployBotServer struct {
}

func (UnimplementedDeployBotServer) DeployBotFunc(context.Context, *DeployBotReq) (*DeployBotRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeployBotFunc not implemented")
}
func (UnimplementedDeployBotServer) mustEmbedUnimplementedDeployBotServer() {}

// UnsafeDeployBotServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeployBotServer will
// result in compilation errors.
type UnsafeDeployBotServer interface {
	mustEmbedUnimplementedDeployBotServer()
}

func RegisterDeployBotServer(s grpc.ServiceRegistrar, srv DeployBotServer) {
	s.RegisterService(&DeployBot_ServiceDesc, srv)
}

func _DeployBot_DeployBotFunc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployBotReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployBotServer).DeployBotFunc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/DeployBot/DeployBotFunc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployBotServer).DeployBotFunc(ctx, req.(*DeployBotReq))
	}
	return interceptor(ctx, in, info, handler)
}

// DeployBot_ServiceDesc is the grpc.ServiceDesc for DeployBot service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeployBot_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "DeployBot",
	HandlerType: (*DeployBotServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeployBotFunc",
			Handler:    _DeployBot_DeployBotFunc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/service.proto",
}

// RemoveBotClient is the client API for RemoveBot service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RemoveBotClient interface {
	RemoveBotFunc(ctx context.Context, in *RemoveBotReq, opts ...grpc.CallOption) (*RemoveBotRes, error)
}

type removeBotClient struct {
	cc grpc.ClientConnInterface
}

func NewRemoveBotClient(cc grpc.ClientConnInterface) RemoveBotClient {
	return &removeBotClient{cc}
}

func (c *removeBotClient) RemoveBotFunc(ctx context.Context, in *RemoveBotReq, opts ...grpc.CallOption) (*RemoveBotRes, error) {
	out := new(RemoveBotRes)
	err := c.cc.Invoke(ctx, "/RemoveBot/RemoveBotFunc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RemoveBotServer is the server API for RemoveBot service.
// All implementations must embed UnimplementedRemoveBotServer
// for forward compatibility
type RemoveBotServer interface {
	RemoveBotFunc(context.Context, *RemoveBotReq) (*RemoveBotRes, error)
	mustEmbedUnimplementedRemoveBotServer()
}

// UnimplementedRemoveBotServer must be embedded to have forward compatible implementations.
type UnimplementedRemoveBotServer struct {
}

func (UnimplementedRemoveBotServer) RemoveBotFunc(context.Context, *RemoveBotReq) (*RemoveBotRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveBotFunc not implemented")
}
func (UnimplementedRemoveBotServer) mustEmbedUnimplementedRemoveBotServer() {}

// UnsafeRemoveBotServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RemoveBotServer will
// result in compilation errors.
type UnsafeRemoveBotServer interface {
	mustEmbedUnimplementedRemoveBotServer()
}

func RegisterRemoveBotServer(s grpc.ServiceRegistrar, srv RemoveBotServer) {
	s.RegisterService(&RemoveBot_ServiceDesc, srv)
}

func _RemoveBot_RemoveBotFunc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveBotReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoveBotServer).RemoveBotFunc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/RemoveBot/RemoveBotFunc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoveBotServer).RemoveBotFunc(ctx, req.(*RemoveBotReq))
	}
	return interceptor(ctx, in, info, handler)
}

// RemoveBot_ServiceDesc is the grpc.ServiceDesc for RemoveBot service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RemoveBot_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "RemoveBot",
	HandlerType: (*RemoveBotServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RemoveBotFunc",
			Handler:    _RemoveBot_RemoveBotFunc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/service.proto",
}

// PublishBotClient is the client API for PublishBot service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PublishBotClient interface {
	PublishBotFunc(ctx context.Context, in *PublishBotReq, opts ...grpc.CallOption) (*PublishBotRes, error)
}

type publishBotClient struct {
	cc grpc.ClientConnInterface
}

func NewPublishBotClient(cc grpc.ClientConnInterface) PublishBotClient {
	return &publishBotClient{cc}
}

func (c *publishBotClient) PublishBotFunc(ctx context.Context, in *PublishBotReq, opts ...grpc.CallOption) (*PublishBotRes, error) {
	out := new(PublishBotRes)
	err := c.cc.Invoke(ctx, "/PublishBot/PublishBotFunc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PublishBotServer is the server API for PublishBot service.
// All implementations must embed UnimplementedPublishBotServer
// for forward compatibility
type PublishBotServer interface {
	PublishBotFunc(context.Context, *PublishBotReq) (*PublishBotRes, error)
	mustEmbedUnimplementedPublishBotServer()
}

// UnimplementedPublishBotServer must be embedded to have forward compatible implementations.
type UnimplementedPublishBotServer struct {
}

func (UnimplementedPublishBotServer) PublishBotFunc(context.Context, *PublishBotReq) (*PublishBotRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishBotFunc not implemented")
}
func (UnimplementedPublishBotServer) mustEmbedUnimplementedPublishBotServer() {}

// UnsafePublishBotServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PublishBotServer will
// result in compilation errors.
type UnsafePublishBotServer interface {
	mustEmbedUnimplementedPublishBotServer()
}

func RegisterPublishBotServer(s grpc.ServiceRegistrar, srv PublishBotServer) {
	s.RegisterService(&PublishBot_ServiceDesc, srv)
}

func _PublishBot_PublishBotFunc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishBotReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublishBotServer).PublishBotFunc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PublishBot/PublishBotFunc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublishBotServer).PublishBotFunc(ctx, req.(*PublishBotReq))
	}
	return interceptor(ctx, in, info, handler)
}

// PublishBot_ServiceDesc is the grpc.ServiceDesc for PublishBot service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PublishBot_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "PublishBot",
	HandlerType: (*PublishBotServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PublishBotFunc",
			Handler:    _PublishBot_PublishBotFunc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/service.proto",
}
